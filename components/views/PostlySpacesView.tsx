
import React, { useState, useRef, useEffect, useContext, useCallback } from 'react';
import { ProjectContext } from '../../contexts/ProjectContext';
import { 
    WorkflowIcon, CreatePostIcon, ImageIcon, VideoCameraIcon, 
    SparklesIcon, Loader, TrashIcon, MagicWandIcon, 
    ArrowsRightLeftIcon, BoltIcon, DocumentTextIcon, LightBulbIcon,
    EyeIcon, PaintBrushIcon
} from '../Icons';
import Button from '../Button';
import * as geminiService from '../../services/geminiService';
import { ARCHIVE_STORAGE_KEY } from '../../constants';
import { getItem, setItem } from '../../utils/localStorage';
import CopyButton from '../CopyButton';

// --- TYPES & CONFIGURATION ---

type NodeType = 'INPUT' | 'AI_WRITER' | 'AI_IMAGE' | 'PROMPT_ENHANCER' | 'TRANSLATOR' | 'OUTPUT';

interface NodeConfig {
    id: NodeType;
    labelAr: string;
    labelEn: string;
    icon: React.ReactNode;
    color: string;
    descriptionAr: string;
    descriptionEn: string;
}

const NODE_REGISTRY: Record<NodeType, NodeConfig> = {
    INPUT: { 
        id: 'INPUT', 
        labelAr: 'مدخلات (فكرة)', 
        labelEn: 'Input (Idea)', 
        icon: <LightBulbIcon className="w-5 h-5"/>, 
        color: '#F59E0B',
        descriptionAr: 'نقطة البداية: اكتب فكرتك أو الموضوع هنا.',
        descriptionEn: 'Start here: Enter your topic or raw idea.'
    },
    AI_WRITER: { 
        id: 'AI_WRITER', 
        labelAr: 'كاتب ذكي', 
        labelEn: 'AI Writer', 
        icon: <CreatePostIcon className="w-5 h-5"/>, 
        color: '#3B82F6',
        descriptionAr: 'يحول المدخلات إلى محتوى (منشور، مقال، وصف).',
        descriptionEn: 'Turns input into content (Post, Article, Bio).'
    },
    PROMPT_ENHANCER: { 
        id: 'PROMPT_ENHANCER', 
        labelAr: 'محسن الأوامر', 
        labelEn: 'Prompt Magic', 
        icon: <SparklesIcon className="w-5 h-5"/>, 
        color: '#8B5CF6',
        descriptionAr: 'يقوم بتحسين النص ليكون جاهزاً لتوليد الصور.',
        descriptionEn: 'Optimizes text to be a perfect image prompt.'
    },
    AI_IMAGE: { 
        id: 'AI_IMAGE', 
        labelAr: 'مولد الصور', 
        labelEn: 'Image Gen', 
        icon: <ImageIcon className="w-5 h-5"/>, 
        color: '#EC4899',
        descriptionAr: 'يولد صورة بناءً على النص السابق.',
        descriptionEn: 'Generates an image based on the previous text.'
    },
    TRANSLATOR: { 
        id: 'TRANSLATOR', 
        labelAr: 'مترجم', 
        labelEn: 'Translator', 
        icon: <ArrowsRightLeftIcon className="w-5 h-5"/>, 
        color: '#10B981',
        descriptionAr: 'يترجم النص إلى الإنجليزية أو العربية.',
        descriptionEn: 'Translates text to English or Arabic.'
    },
    OUTPUT: { 
        id: 'OUTPUT', 
        labelAr: 'النتيجة النهائية', 
        labelEn: 'Final Output', 
        icon: <DocumentTextIcon className="w-5 h-5"/>, 
        color: '#64748B',
        descriptionAr: 'يعرض النتيجة النهائية ويحفظها في الأرشيف.',
        descriptionEn: 'Displays final result and saves to archive.'
    }
};

interface NodeData {
    id: string;
    type: NodeType;
    x: number;
    y: number;
    label: string; // Custom label given by user
    inputValue: string; // Static input (for INPUT nodes)
    result: string | null; // The output generated by this node
    status: 'idle' | 'running' | 'success' | 'error';
    errorMessage?: string;
}

interface Connection {
    id: string;
    from: string; // Node ID
    to: string;   // Node ID
}

// --- MAIN COMPONENT ---

const PostlySpacesView: React.FC = () => {
    const { appLanguage } = useContext(ProjectContext);
    const isAr = appLanguage === 'ar';

    // State
    const [nodes, setNodes] = useState<NodeData[]>([]);
    const [connections, setConnections] = useState<Connection[]>([]);
    const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
    
    // Refs for safe access in async functions
    const nodesRef = useRef(nodes);
    const connectionsRef = useRef(connections);

    // Sync Refs
    useEffect(() => {
        nodesRef.current = nodes;
        connectionsRef.current = connections;
    }, [nodes, connections]);
    
    // Canvas Interaction State
    const [isDraggingNode, setIsDraggingNode] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
    const [isConnecting, setIsConnecting] = useState<string | null>(null);
    const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
    const canvasRef = useRef<HTMLDivElement>(null);

    // Initial Load
    useEffect(() => {
        if (nodes.length === 0) {
            const startId = `node-${Date.now()}`;
            const writerId = `node-${Date.now()+1}`;
            const outputId = `node-${Date.now()+2}`;
            
            setNodes([
                { id: startId, type: 'INPUT', x: 100, y: 200, label: isAr ? 'الفكرة (ابدأ هنا)' : 'Topic (Start Here)', inputValue: '', result: null, status: 'idle' },
                { id: writerId, type: 'AI_WRITER', x: 450, y: 200, label: isAr ? 'صياغة المحتوى' : 'Draft Content', inputValue: '', result: null, status: 'idle' },
                { id: outputId, type: 'OUTPUT', x: 800, y: 200, label: isAr ? 'النتيجة النهائية' : 'Final Result', inputValue: '', result: null, status: 'idle' }
            ]);
            setConnections([
                { id: `conn-${Date.now()}`, from: startId, to: writerId },
                { id: `conn-${Date.now()+1}`, from: writerId, to: outputId }
            ]);
        }
    }, []);

    // --- NODE MANAGEMENT ---

    const addNode = (type: NodeType) => {
        // Calculate position: Center of visible canvas or offset from last node
        const lastNode = nodes[nodes.length - 1];
        const newX = lastNode ? lastNode.x + 50 : 200;
        const newY = lastNode ? lastNode.y + 50 : 200;

        const newNode: NodeData = {
            id: `node-${Date.now()}`,
            type,
            x: newX,
            y: newY,
            label: isAr ? NODE_REGISTRY[type].labelAr : NODE_REGISTRY[type].labelEn,
            inputValue: '',
            result: null,
            status: 'idle'
        };
        setNodes([...nodes, newNode]);
    };

    const deleteNode = (id: string) => {
        setNodes(nodes.filter(n => n.id !== id));
        setConnections(connections.filter(c => c.from !== id && c.to !== id));
        if (selectedNodeId === id) setSelectedNodeId(null);
    };

    const updateNode = (id: string, updates: Partial<NodeData>) => {
        setNodes(prev => prev.map(n => n.id === id ? { ...n, ...updates } : n));
    };

    // --- GRAPH EXECUTION ENGINE ---

    const runWorkflow = async () => {
        // Use refs to get latest state immediately
        const currentNodes = nodesRef.current;
        const currentConnections = connectionsRef.current;

        // Reset statuses
        setNodes(prev => prev.map(n => ({ ...n, status: 'idle', result: null, errorMessage: undefined })));

        // Find Start Nodes (Inputs without incoming connections OR generic Input nodes)
        const startNodes = currentNodes.filter(n => n.type === 'INPUT');
        
        if (startNodes.length === 0) {
            alert(isAr ? "يرجى إضافة عقدة 'مدخلات' للبدء." : "Please add an 'Input' node to start.");
            return;
        }

        // We need a way to access the *latest* state during async execution.
        const resultsMap: Record<string, string> = {};
        
        let lastProcessedNodeId: string | null = null;

        // Helper to update UI state for a node
        const setNodeStatus = (id: string, status: NodeData['status'], result: string | null = null, error?: string) => {
            setNodes(prev => prev.map(n => n.id === id ? { ...n, status, result: result ?? n.result, errorMessage: error } : n));
        };

        const processNode = async (nodeId: string) => {
            // Always find from ref to ensure we have latest data (especially inputValue)
            const node = nodesRef.current.find(n => n.id === nodeId);
            if (!node) return;

            setNodeStatus(nodeId, 'running');

            try {
                let output = "";
                
                // 1. Gather Input Data
                if (node.type === 'INPUT') {
                    output = node.inputValue || "";
                    if (!output.trim()) throw new Error(isAr ? "الرجاء كتابة نص في عقدة المدخلات" : "Please enter text in the Input node");
                } else {
                    const incomingEdges = connectionsRef.current.filter(c => c.to === nodeId);
                    const parentOutputs = incomingEdges.map(c => resultsMap[c.from]).filter(Boolean);
                    
                    if (parentOutputs.length === 0) {
                        // Wait.. maybe parent hasn't finished? 
                        // In this simple recursion, parents are processed. If no output, it means error or disconnection.
                        throw new Error(isAr ? "لا توجد مدخلات من العقدة السابقة" : "No input from previous node");
                    }
                    const inputPayload = parentOutputs.join('\n\n');

                    // 2. Execute Logic based on Type
                    switch (node.type) {
                        case 'AI_WRITER':
                            output = await geminiService.generateRawContent(
                                `Task: Write creative content based on this input.\nInput: "${inputPayload}"\nLanguage: ${isAr ? 'Arabic' : 'English'}`
                            );
                            break;
                        
                        case 'PROMPT_ENHANCER':
                            output = await geminiService.enhancePrompt(inputPayload, "High quality creative generation");
                            break;

                        case 'TRANSLATOR':
                            output = await geminiService.translateToEnglish(inputPayload);
                            break;

                        case 'AI_IMAGE':
                            const prompt = inputPayload.substring(0, 500); 
                            const b64 = await geminiService.generateImage(prompt, 'gemini-2.5-flash-image', '1:1', 'Cinematic');
                            output = `data:image/jpeg;base64,${b64}`;
                            break;

                        case 'OUTPUT':
                            output = inputPayload; // Pass through
                            const archive = getItem(ARCHIVE_STORAGE_KEY, []);
                            archive.unshift({ 
                                id: Date.now().toString(), 
                                type: 'PostlySpaces', 
                                content: output, 
                                timestamp: new Date().toISOString() 
                            });
                            setItem(ARCHIVE_STORAGE_KEY, archive);
                            break;
                    }
                }

                // Success
                resultsMap[nodeId] = output;
                setNodeStatus(nodeId, 'success', output);
                lastProcessedNodeId = nodeId;

                // Add children to queue
                const outgoingEdges = connectionsRef.current.filter(c => c.from === nodeId);
                for (const edge of outgoingEdges) {
                    await processNode(edge.to); 
                }

            } catch (error: any) {
                console.error(`Error in node ${nodeId}:`, error);
                setNodeStatus(nodeId, 'error', null, error.message);
            }
        };

        // Start processing
        for (const startNode of startNodes) {
            await processNode(startNode.id);
        }

        // Auto-select the last processed node (usually Output) to show results
        if (lastProcessedNodeId) {
            setSelectedNodeId(lastProcessedNodeId);
        }
    };

    // --- CANVAS EVENTS ---

    const handleMouseDown = (e: React.MouseEvent, id: string) => {
        e.stopPropagation();
        
        // Handling Connections
        if (isConnecting) {
            if (isConnecting !== id) {
                if (!connections.some(c => c.from === isConnecting && c.to === id)) {
                    setConnections([...connections, { id: `conn-${Date.now()}`, from: isConnecting, to: id }]);
                }
            }
            setIsConnecting(null);
            return;
        }

        // Selection & Dragging
        setSelectedNodeId(id);
        const node = nodes.find(n => n.id === id);
        if (node) {
            setIsDraggingNode(id);
            setDragOffset({
                x: e.clientX - node.x,
                y: e.clientY - node.y
            });
        }
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (isDraggingNode) {
            const newX = e.clientX - dragOffset.x;
            const newY = e.clientY - dragOffset.y;
            updateNode(isDraggingNode, { x: newX, y: newY });
        }
        if (isConnecting && canvasRef.current) {
            const rect = canvasRef.current.getBoundingClientRect();
            setMousePos({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
        }
    };

    const handleMouseUp = () => {
        setIsDraggingNode(null);
    };

    const handleCanvasClick = () => {
        setIsConnecting(null);
        setSelectedNodeId(null);
    };

    const startConnection = (e: React.MouseEvent, id: string) => {
        e.stopPropagation();
        setIsConnecting(id);
    };

    // --- RENDER HELPERS ---

    const getConnectorPoint = (nodeId: string, type: 'input' | 'output') => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return { x: 0, y: 0 };
        const width = 240; 
        const height = 100;
        
        if (type === 'input') {
            return { x: node.x, y: node.y + (height / 2) };
        } else {
            return { x: node.x + width, y: node.y + (height / 2) }; 
        }
    };

    const renderPath = (x1: number, y1: number, x2: number, y2: number) => {
        const dist = Math.abs(x2 - x1) * 0.5;
        return `M ${x1} ${y1} C ${x1 + dist} ${y1}, ${x2 - dist} ${y2}, ${x2} ${y2}`;
    };

    const selectedNode = nodes.find(n => n.id === selectedNodeId);

    return (
        <div className="h-full flex flex-col animate-fade-in pb-20 relative bg-black/10 rounded-xl overflow-hidden border border-white/5">
            {/* TOOLBAR */}
            <div className="bg-[#0a1e3c] border-b border-white/10 p-4 flex flex-col md:flex-row justify-between items-center gap-4 z-10 shadow-md">
                <div className="flex items-center gap-2">
                    <WorkflowIcon className="w-6 h-6 text-[#bf8339]" />
                    <div>
                        <h2 className="text-lg font-bold text-white">{isAr ? 'مساحات العمل' : 'Postly Spaces'}</h2>
                        <p className="text-[10px] text-white/50">{isAr ? 'قم ببناء مسارات عمل ذكية' : 'Build AI workflows visually'}</p>
                    </div>
                </div>
                
                <div className="flex gap-2 bg-black/20 p-1 rounded-lg overflow-x-auto max-w-full">
                    {Object.values(NODE_REGISTRY).map((conf) => (
                        <button
                            key={conf.id}
                            onClick={() => addNode(conf.id)}
                            className="flex items-center gap-1 px-3 py-1.5 rounded bg-white/5 hover:bg-white/10 border border-white/5 hover:border-white/20 transition text-xs whitespace-nowrap text-white"
                            title={isAr ? conf.descriptionAr : conf.descriptionEn}
                        >
                            <span style={{color: conf.color}}>{conf.icon}</span>
                            <span>{isAr ? conf.labelAr : conf.labelEn}</span>
                        </button>
                    ))}
                </div>

                <Button onClick={runWorkflow} className="!py-2 !px-6 !text-sm flex items-center gap-2 shadow-lg shadow-[#bf8339]/20">
                    <BoltIcon className="w-4 h-4" /> {isAr ? 'تشغيل' : 'Run Flow'}
                </Button>
            </div>

            {/* MAIN WORKSPACE */}
            <div className="flex-1 relative overflow-hidden flex">
                
                {/* CANVAS */}
                <div 
                    ref={canvasRef}
                    className="flex-1 bg-[#111827] relative cursor-grab active:cursor-grabbing overflow-hidden"
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onClick={handleCanvasClick}
                    style={{ 
                        backgroundImage: 'radial-gradient(#334155 1px, transparent 1px)', 
                        backgroundSize: '20px 20px' 
                    }}
                >
                    <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
                        {/* Connections */}
                        {connections.map(conn => {
                            const start = getConnectorPoint(conn.from, 'output');
                            const end = getConnectorPoint(conn.to, 'input');
                            return (
                                <g key={conn.id}>
                                    <path 
                                        d={renderPath(start.x, start.y, end.x, end.y)}
                                        stroke="#4B5563"
                                        strokeWidth="3"
                                        fill="none"
                                        className="transition-all hover:stroke-[#bf8339]"
                                    />
                                    <circle cx={end.x} cy={end.y} r="3" fill="#bf8339" />
                                </g>
                            );
                        })}
                        {/* Dragging Line */}
                        {isConnecting && mousePos.x !== 0 && (
                            <path 
                                d={(() => {
                                    const start = getConnectorPoint(isConnecting, 'output');
                                    return renderPath(start.x, start.y, mousePos.x, mousePos.y);
                                })()}
                                stroke="#bf8339"
                                strokeWidth="2"
                                strokeDasharray="5,5"
                                fill="none"
                            />
                        )}
                    </svg>

                    {/* Nodes */}
                    {nodes.map(node => {
                        const conf = NODE_REGISTRY[node.type];
                        const isSelected = selectedNodeId === node.id;
                        return (
                            <div
                                key={node.id}
                                className={`absolute w-[240px] bg-[#1F2937] rounded-xl border-2 transition-all shadow-xl flex flex-col group ${
                                    isSelected ? 'border-[#bf8339] shadow-[#bf8339]/20 z-20' : 'border-[#374151] hover:border-gray-500 z-10'
                                }`}
                                style={{ 
                                    left: node.x, 
                                    top: node.y,
                                }}
                                onMouseDown={(e) => handleMouseDown(e, node.id)}
                            >
                                {/* Header */}
                                <div 
                                    className="p-3 rounded-t-lg flex items-center justify-between"
                                    style={{ background: `linear-gradient(to right, ${conf.color}22, transparent)` }}
                                >
                                    <div className="flex items-center gap-2">
                                        <div className="p-1 rounded bg-black/20" style={{color: conf.color}}>
                                            {conf.icon}
                                        </div>
                                        <span className="text-xs font-bold text-white truncate max-w-[120px]">{node.label}</span>
                                    </div>
                                    {/* Status Indicator */}
                                    {node.status === 'running' && <Loader />}
                                    {node.status === 'success' && <span className="text-green-400 text-xs">✓</span>}
                                    {node.status === 'error' && <span className="text-red-400 text-xs">!</span>}
                                </div>

                                {/* Body Preview */}
                                <div className="p-3 bg-[#111827]/50 min-h-[70px] max-h-[110px] overflow-hidden text-[10px] text-gray-400 relative flex flex-col justify-between">
                                    {node.result ? (
                                        node.result.startsWith('data:image') ? (
                                            <img src={node.result} className="w-full h-16 object-cover rounded" />
                                        ) : (
                                            <p className="line-clamp-3 mb-1">{node.result}</p>
                                        )
                                    ) : node.inputValue ? (
                                        <p className="italic mb-1">"{node.inputValue}"</p>
                                    ) : (
                                        <p className="opacity-50 mb-1">{isAr ? 'لا توجد بيانات' : 'No data'}</p>
                                    )}

                                    {/* ACTION BUTTON ON CARD */}
                                    {node.type === 'INPUT' ? (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); setSelectedNodeId(node.id); }}
                                            className="mt-1 w-full bg-white/5 hover:bg-white/10 text-white/80 py-1 rounded text-[10px] flex items-center justify-center gap-1 border border-white/5 transition"
                                        >
                                            <PaintBrushIcon className="w-3 h-3" /> {isAr ? 'اضغط للكتابة' : 'Click to Write'}
                                        </button>
                                    ) : node.status === 'success' ? (
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); setSelectedNodeId(node.id); }}
                                            className="mt-1 w-full bg-[#bf8339]/20 hover:bg-[#bf8339]/30 text-[#bf8339] py-1 rounded text-[10px] flex items-center justify-center gap-1 border border-[#bf8339]/20 transition"
                                        >
                                            <EyeIcon className="w-3 h-3" /> {isAr ? 'مشاهدة النتيجة' : 'View Result'}
                                        </button>
                                    ) : null}
                                </div>

                                {/* Handles */}
                                <div 
                                    className="absolute -left-3 top-1/2 w-3 h-3 bg-gray-400 rounded-full hover:scale-150 transition cursor-crosshair border border-[#1F2937]"
                                    title="Input"
                                ></div>
                                <div 
                                    className="absolute -right-3 top-1/2 w-3 h-3 bg-[#bf8339] rounded-full hover:scale-150 transition cursor-crosshair border border-[#1F2937]"
                                    onMouseDown={(e) => startConnection(e, node.id)}
                                    title="Output"
                                ></div>
                            </div>
                        );
                    })}
                </div>

                {/* RIGHT SIDEBAR: PROPERTIES & OUTPUT */}
                <div className={`w-80 bg-[#0a1e3c] border-l border-white/10 flex flex-col transition-all duration-300 absolute right-0 top-0 bottom-0 z-30 shadow-2xl transform ${selectedNodeId ? 'translate-x-0' : 'translate-x-full md:translate-x-0 md:static'}`}>
                    <div className="p-4 border-b border-white/10 bg-[#0a1e3c] flex justify-between items-center">
                        <h3 className="text-sm font-bold text-white">{isAr ? 'خصائص العقدة' : 'Node Properties'}</h3>
                        <button onClick={() => setSelectedNodeId(null)} className="md:hidden text-white/50 hover:text-white">✕</button>
                    </div>
                    
                    {selectedNode ? (
                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            {/* Label Edit */}
                            <div>
                                <label className="text-xs text-white/50 block mb-1">{isAr ? 'الاسم' : 'Label'}</label>
                                <input 
                                    type="text" 
                                    value={selectedNode.label}
                                    onChange={(e) => updateNode(selectedNode.id, { label: e.target.value })}
                                    className="w-full bg-black/20 border border-white/10 rounded p-2 text-white text-sm focus:border-[#bf8339]"
                                />
                            </div>

                            {/* Input Value (Only for INPUT nodes) */}
                            {selectedNode.type === 'INPUT' && (
                                <div className="animate-fade-in">
                                    <label className="text-xs text-[#bf8339] font-bold block mb-1">{isAr ? 'القيمة المدخلة (اكتب هنا)' : 'Input Value (Write Here)'}</label>
                                    <textarea 
                                        value={selectedNode.inputValue}
                                        onChange={(e) => updateNode(selectedNode.id, { inputValue: e.target.value })}
                                        className="w-full bg-black/20 border border-white/10 rounded p-3 text-white text-sm h-40 focus:border-[#bf8339] focus:ring-1 focus:ring-[#bf8339]/50"
                                        placeholder={isAr ? "مثال: أريد فكرة لمنشور عن القهوة الصباحية..." : "Type your idea here..."}
                                        autoFocus
                                    />
                                </div>
                            )}

                            {/* Result Display */}
                            {selectedNode.result && (
                                <div className="animate-fade-in">
                                    <label className="text-xs text-[#bf8339] block mb-2 font-bold">{isAr ? 'المخرجات' : 'Output Result'}</label>
                                    <div className="bg-black/30 rounded-lg border border-white/5 p-3 overflow-hidden">
                                        {selectedNode.result.startsWith('data:image') ? (
                                            <div>
                                                <img src={selectedNode.result} className="w-full rounded mb-2" />
                                                <a 
                                                    href={selectedNode.result} 
                                                    download={`node-${selectedNode.id}.jpg`}
                                                    className="block text-center bg-white/10 py-2 rounded text-xs text-white hover:bg-white/20 font-bold"
                                                >
                                                    {isAr ? 'تحميل الصورة' : 'Download Image'}
                                                </a>
                                            </div>
                                        ) : (
                                            <div>
                                                <p className="text-sm text-white/80 whitespace-pre-wrap leading-relaxed max-h-80 overflow-y-auto custom-scrollbar">
                                                    {selectedNode.result}
                                                </p>
                                                <div className="mt-2 flex justify-end">
                                                    <CopyButton text={selectedNode.result} />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {/* Error Display */}
                            {selectedNode.errorMessage && (
                                <div className="bg-red-500/10 border border-red-500/30 p-3 rounded text-xs text-red-300">
                                    {selectedNode.errorMessage}
                                </div>
                            )}

                            {/* Delete Action */}
                            <div className="pt-6 border-t border-white/10 mt-auto">
                                <button 
                                    onClick={() => deleteNode(selectedNode.id)}
                                    className="w-full flex items-center justify-center gap-2 py-2 text-red-400 bg-red-500/10 hover:bg-red-500/20 rounded border border-red-500/20 transition text-sm"
                                >
                                    <TrashIcon className="w-4 h-4" /> {isAr ? 'حذف العقدة' : 'Delete Node'}
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-1 flex flex-col items-center justify-center text-white/30 p-6 text-center">
                            <WorkflowIcon className="w-12 h-12 mb-4 opacity-50" />
                            <p className="text-sm font-bold mb-2">{isAr ? 'لم يتم تحديد عقدة' : 'No Node Selected'}</p>
                            <p className="text-xs opacity-70">
                                {isAr 
                                    ? 'اضغط على عقدة "المدخلات" للكتابة، أو اضغط "تشغيل" ثم اختر عقدة "النتيجة" لرؤية المخرجات.' 
                                    : 'Click "Input" to write, or click "Run" then select "Output" to see results.'}
                            </p>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default PostlySpacesView;
